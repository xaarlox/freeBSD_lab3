# freeBSD_lab3

## Завдання №1
Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. Для цього виконайте команди у порядку, який був вказаний у практичній роботі.
### Примітка
Оскільки операційна система FreeBSD не підтримує запуск Docker-контейнерів через відсутність повноцінної реалізації Linux-namespace та cgroups, які є необхідними для роботи Docker, було прийнято рішення пропустити виконання вправ 3.1 та 3.2 у середовищі Docker. Натомість вправу 3.1 було виконано безпосередньо в середовищі FreeBSD, з дослідженням лімітів відкритих файлів на рівні root.
### Виконання програми
![Знімок екрана 2025-03-13 153437](https://github.com/user-attachments/assets/a7239d6a-10dc-459e-9746-c33fbf6ff95e)

## Завдання №3
Напишіть програму, що імітує кидання шестигранного кубика. Імітуйте кидки, результати записуйте у файл, для якого попередньо встановлено обмеження на його максимальний розмір (max file size). Коректно обробіть ситуацію перевищення ліміту.
## Реалізація завдання
Було написано програму, яка працює наступним чином:
+ На початку ініціалізується генератор випадкових чисел;
+ Відкривається файл `roll_dice.txt` у режимі дозапису `(append)`;
+ У нескінченному циклі програма генерує випадкове число від 1 до та записує його у файл;
+ Перед кожним записом перевіряється поточний розмір файлу. Якщо розмір досягає або перевищує заданий ліміт у 1024 байти, запис припиняється, а користувач отримує повідомлення про досягнення ліміту;
+ У разі помилки запису виводиться відповідне повідомлення;
+ Після завершення роботи виводиться останній кинутий результат кубика.
## Компіляція та виконання програми
![Знімок екрана 2025-03-13 160657](https://github.com/user-attachments/assets/7fc57cd2-e493-44ae-a1ea-2d484334ca28)

## Завдання №4
Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.
## Реалізація завдання
Було написано програму, яка виконує такі основні дії:
* Встановлює обмеження на використання часу ЦП (CPU time) на рівні *1 секунди* для запобігання надмірному навантаженню або зацикленню. У разі перевищення ліміту виконується аварійне завершення з відповідним повідомленням;
* За допомогою функції генерації унікальних чисел формує 7 випадкових унікальних чисел у діапазоні від 1 до 49 та 6 випадкових унікальних чисел у діапазоні від 1 до 36;
* Кожна згенерована послідовність чисел виводиться на екран у відповідному форматі: *"7 of 49"* для першої лотереї та *"6 of 36"* для другої лотереї.
Основною ідеєю було змоделювання процесу випадкового вибору чисел для лотереї з контролем використання ресурсів системи.
## Компіляція та виконання програми
![Знімок екрана 2025-03-13 172527](https://github.com/user-attachments/assets/d8d5007a-1be7-4cd3-971d-7382746d105d)

## Завдання №5
Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів. Програма має відповідати вимогам, які були описані в практичній роботі.
## Реалізація завдання
Було написано програму опис якої наведено нижче.
- *Реалізовано перевірку аргументів командного рядка.* Програма приймає два аргументи: шлях до вихідного файлу і шлях до файлу-призначення. Якщо аргументів менше або більше двох, виводиться повідомлення про помилку, і виконання припиняється.
- *Перевірка існування та розміру вихідного файлу.* За допомогою `stat()` отримується інформація про вихідний файл. Якщо файл не існує або його неможливо відкрити, програма виводить помилку. Якщо розмір файлу перевищує 10 МБ, копіювання не виконується.
- *Відкриття файлів.* Вихідний файл відкривається у режимі лише для читання. Файл-призначення відкривається у режимі запису, якщо він існує – його вміст очищається, якщо ні – він створюється з правами доступу. У разі невдалого відкриття одного з файлів програма виводить помилку і завершує роботу.
- *Читання з вихідного файлу та запис у файл-призначення.* Використовується буфер розміром `4096` байтів. Читається порція даних з вихідного файлу і одразу записується у файл-призначення. Якщо під час запису виникає помилка (наприклад, не всі дані були записані), програма зупиняє копіювання і завершується.
- *Закриття файлів та завершення програми.* Після успішного копіювання файли закриваються, і програма завершує роботу.
## Компіляція та виконання програми
![Знімок екрана 2025-03-13 172621](https://github.com/user-attachments/assets/8a8c9526-75ef-40cf-bade-0a0fe8638e53)

## Завдання №6
Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек.
## Реалізація завдання
Було написано програму, яка виконує наступні функції:
+ *Отримує поточний ліміт розміру стеку процесу.* За допомогою `getrlimit(RLIMIT_STACK, &limit)` отримується поточний ліміт стекової пам'яті. Якщо виклик успішний, виводиться значення `limit.rlim_cur`. У разі помилки виводиться повідомлення `perror("getrlimit")`, і програма завершується з `EXIT_FAILURE`.
+ *Містить рекурсивну функцію `recurse()`.* Функція `recurse(int count)` виводить глибину рекурсії (`count`) і викликає саму себе з інкрементованим значенням. Це потенційно може викликати переповнення стеку, якщо рекурсія не буде зупинена.  

У головній функції програми викликається рекурсивна функція, (`recurse(1)`). Отже, програма запускає нескінченну рекурсію до вичерпання стеку.  
## Компіляція та виконання програми
![Знімок екрана 2025-03-13 173617](https://github.com/user-attachments/assets/c6d3f64d-cdd7-4ace-8327-af3e37cad780)


## Завдання №20
Написати програму, яка тестує вплив `ulimit -r` на пріоритети процесів.
## Реалізація завдання
Було розроблено програму для роботи з пріоритетами процесів у FreeBSD. Розглянемо основні змінні у програмі:
* `pid_t pid` – змінна для збереження ідентифікатора процесу;
* `int current_nice` – змінна для збереження поточного пріоритету процесу (nice);
* `int new_priority` – змінна для встановлення нового пріоритету в дочірньому процесі.

### Опис основної логіки:
1. Визначається пріоритет поточного процесу за допомогою `getpriority()`;
2. Використовується `fork()`, щоб створити новий процес;
3. У дочірньому процесі:
- Встановлюється новий пріоритет `-10` через `setpriority()`;
- Викликається `execlp()`, щоб виконати команду `sleep 5`;
4. У батьківському процесі очікується завершення дочірнього процесу через `wait()`.
  
### Основні виклики функцій:  
+ `getpriority(PRIO_PROCESS, 0)` – отримання поточного nice-значення;
+ `setpriority(PRIO_PROCESS, 0, new_priority)` – встановлення нового пріоритету;
+ `fork()` – створення нового процесу;
+ `execlp("sleep", "sleep", "5", NULL)` – запуск команди `sleep 5`;
+ `wait(NULL)` – очікування завершення дочірнього процесу.

### Висновок:  
Програма демонструє зміну пріоритету процесу та використання `fork()` для створення нового процесу, що виконує команду `sleep`.

## Компіляція та виконання програми
![Знімок екрана 2025-03-13 180419](https://github.com/user-attachments/assets/3558a70a-d1d7-4384-acd1-c77f95649750)
